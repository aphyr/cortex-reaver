#!/usr/bin/ruby

require 'rubygems'
require 'optparse'
gem 'ramaze', '=2009.05'
require 'ramaze'
require __DIR__ + '/../lib/cortex_reaver'

module CortexReaver
  # Asks a question and returns a true_false answer
  def self.confirm(question)
    return true if @values[:force]

    puts question + " (yes/no)"
    print '> '
    STDOUT.flush

    if STDIN.gets.strip =~ /^y(?:es)?/i
      true
    else
      false
    end
  end

  # Parse options
  @values = {}
  parser = OptionParser.new do |o|
    o.on '-b', '--blank',
      'Wipes the database and sets up a clean copy of the latest version.' do
      @action = :blank
    end

    o.on '-c', '--config file', 'Configuration file' do |file|
      self.config_file = file
    end

    o.on '-d', '--dump file', 'Dump database' do |file|
      @action = :dump
      @values[:dump_file] = file
    end

    o.on '-f', '--force', 'Just do it' do
      @values[:force] = true
    end

    o.on '-h', '--help', 'Show help' do
      @action = :help
    end

    o.on '-i', '--irb', 'Start an IRB session' do
      @action = :irb
    end

    o.on '-k', '--stop', 'Stop Cortex Reaver' do
      @action = :stop
    end

    o.on '-l', '--load file', 'Load database' do |file|
      @action = :load
      @values[:load_file] = file
    end

    o.on '-m', '--migrate [version]',
      'Migrate the database to schema version, or to the latest version' do |version|
      @action = :migrate
      @values[:schema_version] = version ? version.to_i : nil
    end

    o.on '-r', '--restart', 'Restart Cortex Reaver' do
      @action = :restart
    end

    o.on '-s', '--start',
      'Start the Cortex Reaver server' do
      @action = :start
    end

    o.on '-t', '--test',
      'Run tests' do
      @action = :test
    end

    o.on '--status', 'Check Cortex Reaver status' do
      @action = :status
    end
  end

  parser.parse! ARGV

  # Main
  case @action
  when :dump
    # Dump the database to disk
    
    # Connect to current DB
    reload_config
    setup_db false
    require 'sequel/extensions/migration'
    current_version = Sequel::Migrator.get_current_migration_version(db)

    puts "Using database #{config[:database][:host]}/#{config[:database][:database]}."

    # Prepare dump file
    file = @values[:dump_file]
    if File.file? file
      exit unless confirm("Overwrite #{File.expand_path(file)} with current Cortex Reaver database?")
      FileUtils.rm file
    end

    # Connect to dump DB
    dump = Sequel.connect "sqlite:////#{File.expand_path(file)}"
    Sequel::Migrator.apply dump, File.join(LIB_DIR, 'migrations'), current_version

    # Copy tables
    db.tables.each do |table|
      puts "Table #{table} (#{db[table].count} rows)..."
      dump_table = dump[table]
      db[table].each do |row|
        dump_table << row
      end
    end   
        
    puts "Dumped database to #{file}."

  when :load
    # Load an SQLite database from disk.

    # Connect to dump DB
    file = @values[:load_file]
    dump = Sequel.connect "sqlite:////#{File.expand_path(file)}"
    require 'sequel/extensions/migration'
    current_version = Sequel::Migrator.get_current_migration_version(dump)

    # Connect to current DB
    reload_config
    setup_db false
    puts "Using database #{config[:database][:host]}/#{config[:database][:database]}."

    unless confirm("Overwrite current database with #{File.expand_path(file)}?")
      exit
    end
     
    # Drop current migrations and move to the dump's version
    system($0, '-f', '-m', '0')
    Sequel::Migrator.apply db, File.join(LIB_DIR, 'migrations'), current_version

    # Copy tables
    dump.tables.each do |table|
      puts "Table #{table} (#{dump[table].count} rows)..."
      db_table = db[table]
      dump[table].each do |row|
        db_table << row
      end
    end   
        
    puts "Database #{file} loaded."

  when :status
    # Make a quick HTTP request to see how we're doing.
    require 'open-uri'
    reload_config
    response = open("http://#{config[:host] || 'localhost'}:#{config[:port]}/")
    puts response.status.join(' ');

  when :migrate
    version = @values[:schema_version]

    # Get ready
    reload_config
    setup_db false
    self.load
    init

    puts "Using database #{config[:database][:host]}/#{config[:database][:database]}."

    require 'sequel/extensions/migration'
    current_version = Sequel::Migrator.get_current_migration_version(db)
    latest_version = Sequel::Migrator.latest_migration_version(File.join(LIB_DIR, 'migrations'))

    if version == current_version and current_version == latest_version
      puts "The database is already at the latest version (#{latest_version})."
      exit
    elsif version == current_version
      puts "The database is already at version #{version}."
      exit
    end

    if version == 0
      message = "You are migrating to version 0. This will drop your cortex_reaver database! Are you sure you want to do this?"
    elsif version
      message = "Ready to migrate from version #{current_version} to version #{version}?"
    else
      message = "Ready to migrate from version #{current_version} to latest version (#{latest_version})?"
    end

    if confirm message
      puts "Migrating database from version #{current_version} to version #{version}..."
      Sequel::Migrator.apply(db, File.join(LIB_DIR, 'migrations'), version)
      puts "Done."
    else
      exit
    end

  when :blank
    if confirm "Are you sure you wish to wipe the database?"
      # Strangely, calling Migrator.apply to go down and then up doesn't seem
      # to work. :-/
      system($0, '-f', '-m', '0')
      system($0, '-f', '-m')
    end

  when :help
    puts "Cortex Reaver #{APP_VERSION}: A dangerous Ruby blog engine, with a photographic memory."
    puts parser.help

  when :irb
    # Start an IRB session
    reload_config
    setup

    # Don't let IRB try to interpret our command line
    ARGV.clear

    require 'irb'
    require 'irb/completion'

    IRB.start

  when :restart
    restart

  when :start
    start

  when :stop
    stop

  when :test
    require File.join(LIB_DIR, '..', '..', 'spec', 'spec')

  else
    abort("Unknown action: #{@action}")
  end
end
